<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="Array__tools_8cpp" kind="file" language="C++">
    <compoundname>Array_tools.cpp</compoundname>
    <includes refid="Array__tools_8h" local="no">Array_tools.h</includes>
      <sectiondef kind="func">
      <memberdef kind="function" id="Array__tools_8cpp_1acf7c82ee01f8e96267a816f9dd9a2c74" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int array_bsearch</definition>
        <argsstring>(const ArrOfInt &amp;tab, int valeur)</argsstring>
        <name>array_bsearch</name>
        <param>
          <type>const <ref refid="classTRUSTArray" kindref="compound">ArrOfInt</ref> &amp;</type>
          <declname>tab</declname>
        </param>
        <param>
          <type>int</type>
          <declname>valeur</declname>
        </param>
        <briefdescription>
<para>cherche la &quot;valeur&quot; dans le tableau tab par recherche binaire Le tableau tab doit etre trie dans l&apos;ordre croissant </para>
        </briefdescription>
        <detaileddescription>
<para>Methode outil pour chercher une valeur dans un tableau trie.</para>
<para>Si elle n&apos;est pas trouvee, renvoie -1 (y compris si tab est vide), sinon, renvoie un index i tel que tab[i] == valeur (si la valeur figure plusieurs fois dans le tableau, on ne renvoie pas forcement la premiere occurence).</para>
<para>Utilise dans Trio ! </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" line="362" column="5" bodyfile="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" bodystart="362" bodyend="385"/>
      </memberdef>
      <memberdef kind="function" id="Array__tools_8cpp_1afb2460262c05a2151e5eba09b4591dd0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename _TYPE_</type>
          </param>
          <param>
            <type>typename _SIZE_</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void array_calculer_intersection</definition>
        <argsstring>(TRUSTArray&lt; _TYPE_, _SIZE_ &gt; &amp;liste1, const TRUSTArray&lt; _TYPE_, _SIZE_ &gt; &amp;liste2)</argsstring>
        <name>array_calculer_intersection</name>
        <param>
          <type><ref refid="classTRUSTArray" kindref="compound">TRUSTArray</ref>&lt; _TYPE_, _SIZE_ &gt; &amp;</type>
          <declname>liste1</declname>
        </param>
        <param>
          <type>const <ref refid="classTRUSTArray" kindref="compound">TRUSTArray</ref>&lt; _TYPE_, _SIZE_ &gt; &amp;</type>
          <declname>liste2</declname>
        </param>
        <briefdescription>
<para>calcule l&apos;intersection entre les deux listes d&apos;entiers liste1 et liste2. </para>
        </briefdescription>
        <detaileddescription>
<para>Methode outil pour calculer l&apos;intersection entre deux listes d&apos;entiers.</para>
<para>Le resultat est mis dans liste1. Les deux listes doivent etre triees et sans doublons. liste1 est triee en sortie. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" line="47" column="6" bodyfile="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" bodystart="47" bodyend="71"/>
      </memberdef>
      <memberdef kind="function" id="Array__tools_8cpp_1a4d843b86d71e5f68fd9324bc3d63f9a3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void array_calculer_intersection</definition>
        <argsstring>(TRUSTArray&lt; int, int &gt; &amp;liste1, const TRUSTArray&lt; int, int &gt; &amp;liste2)</argsstring>
        <name>array_calculer_intersection</name>
        <param>
          <type><ref refid="classTRUSTArray" kindref="compound">TRUSTArray</ref>&lt; int, int &gt; &amp;</type>
          <declname>liste1</declname>
        </param>
        <param>
          <type>const <ref refid="classTRUSTArray" kindref="compound">TRUSTArray</ref>&lt; int, int &gt; &amp;</type>
          <declname>liste2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" line="282" column="15" declfile="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" declline="282" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="Array__tools_8cpp_1a9226d0e9dacc7ea936d9657b316a0214" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void array_retirer_elements</definition>
        <argsstring>(ArrOfInt &amp;sorted_array, const ArrOfInt &amp;sorted_elements_list)</argsstring>
        <name>array_retirer_elements</name>
        <param>
          <type><ref refid="classTRUSTArray" kindref="compound">ArrOfInt</ref> &amp;</type>
          <declname>sorted_array</declname>
        </param>
        <param>
          <type>const <ref refid="classTRUSTArray" kindref="compound">ArrOfInt</ref> &amp;</type>
          <declname>sorted_elements_list</declname>
        </param>
        <briefdescription>
<para>Retire de &quot;sorted_array&quot; les elements qui figurent dans &quot;sorted_elements&quot;. </para>
        </briefdescription>
        <detaileddescription>
<para>Methode outil pour calculer la difference entre deux listes d&apos;entiers triees.</para>
<para>Les deux tableaux doivent etre initialement ordonnes dans l&apos;ordre croissant. Exemple: En entree sorted_array=[1,4,9,10,12,18], sorted_elements=[3,5,9,10,18,25] En sortie sorted_array=[1,4,12] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" line="81" column="6" bodyfile="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" bodystart="81" bodyend="117"/>
      </memberdef>
      <memberdef kind="function" id="Array__tools_8cpp_1a582750753438156dca64345672fbb245" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename _TYPE_</type>
          </param>
          <param>
            <type>typename _SIZE_</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void array_trier_retirer_doublons</definition>
        <argsstring>(TRUSTArray&lt; _TYPE_, _SIZE_ &gt; &amp;array)</argsstring>
        <name>array_trier_retirer_doublons</name>
        <param>
          <type><ref refid="classTRUSTArray" kindref="compound">TRUSTArray</ref>&lt; _TYPE_, _SIZE_ &gt; &amp;</type>
          <declname>array</declname>
        </param>
        <briefdescription>
<para>Trie le tableau array dans l&apos;ordre croissant et retire les doublons. </para>
        </briefdescription>
        <detaileddescription>
<para>Methode outil pour retirer les doublons dans un tableau. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" line="22" column="6" bodyfile="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" bodystart="22" bodyend="36"/>
      </memberdef>
      <memberdef kind="function" id="Array__tools_8cpp_1af82426465c4e557ba00a9dce60ecc433" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void array_trier_retirer_doublons</definition>
        <argsstring>(TRUSTArray&lt; double, int &gt; &amp;array)</argsstring>
        <name>array_trier_retirer_doublons</name>
        <param>
          <type><ref refid="classTRUSTArray" kindref="compound">TRUSTArray</ref>&lt; double, int &gt; &amp;</type>
          <declname>array</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" line="284" column="15" declfile="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" declline="284" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="Array__tools_8cpp_1a495cf7f3bfb4da2e8c2b841486ff2e2d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void array_trier_retirer_doublons</definition>
        <argsstring>(TRUSTArray&lt; int, int &gt; &amp;array)</argsstring>
        <name>array_trier_retirer_doublons</name>
        <param>
          <type><ref refid="classTRUSTArray" kindref="compound">TRUSTArray</ref>&lt; int, int &gt; &amp;</type>
          <declname>array</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" line="283" column="15" declfile="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" declline="283" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="Array__tools_8cpp_1adba59ffed2ffdd0bfbb9f71307e81533" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void calculer_renum_sans_doublons</definition>
        <argsstring>(const IntTab &amp;tab, ArrOfInt &amp;renum, ArrOfInt &amp;renum_inverse)</argsstring>
        <name>calculer_renum_sans_doublons</name>
        <param>
          <type>const <ref refid="classTRUSTTab" kindref="compound">IntTab</ref> &amp;</type>
          <declname>tab</declname>
        </param>
        <param>
          <type><ref refid="classTRUSTArray" kindref="compound">ArrOfInt</ref> &amp;</type>
          <declname>renum</declname>
        </param>
        <param>
          <type><ref refid="classTRUSTArray" kindref="compound">ArrOfInt</ref> &amp;</type>
          <declname>renum_inverse</declname>
        </param>
        <briefdescription>
<para>cherche par un tri lexicographique les lignes identiques de &quot;tab&quot; et initialise les tailles et contenus de renum et renum_inverse. </para>
        </briefdescription>
        <detaileddescription>
<para>Methode outil pour trouver les doublons (permet de retirer les doublons sans changer l&apos;ordre des elements)</para>
<para>renum est de taille tab.dimension_tot(0). renum[i] contiendra l&apos;indice de la ligne i dans le tableau reduit trie (contenant les lignes uniques) renum_inverse contient, pour chaque ligne du tableau reduit trie, le plus petit indice de la ligne correspondante dans tab. on peut construire le tableau reduit trie en extayant les lignes tab( renum_inverse[i], ...) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" line="312" column="6" bodyfile="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" bodystart="312" bodyend="351"/>
      </memberdef>
      <memberdef kind="function" id="Array__tools_8cpp_1adea9d375998c3f169517c16b7d915be5" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename _SIZE_</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>static int same_line</definition>
        <argsstring>(const IntTab_T&lt; _SIZE_ &gt; &amp;v, _SIZE_ i, _SIZE_ j)</argsstring>
        <name>same_line</name>
        <param>
          <type>const <ref refid="classTRUSTTab" kindref="compound">IntTab_T</ref>&lt; _SIZE_ &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>_SIZE_</type>
          <declname>i</declname>
        </param>
        <param>
          <type>_SIZE_</type>
          <declname>j</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" line="120" column="19" bodyfile="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" bodystart="120" bodyend="127"/>
      </memberdef>
      <memberdef kind="function" id="Array__tools_8cpp_1a2b5911fdd430422cadf7c60a7c0d1358" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename _SIZE_</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tableau_trier_retirer_doublons</definition>
        <argsstring>(IntTab_T&lt; _SIZE_ &gt; &amp;tab)</argsstring>
        <name>tableau_trier_retirer_doublons</name>
        <param>
          <type><ref refid="classTRUSTTab" kindref="compound">IntTab_T</ref>&lt; _SIZE_ &gt; &amp;</type>
          <declname>tab</declname>
        </param>
        <briefdescription>
<para>Trie le tableau tab dans l&apos;ordre lexicographique et retire les doublons (attention [1,2] n&apos;est pas egal a [2,1]) </para>
        </briefdescription>
        <detaileddescription>
<para>Methode outil pour retirer les doublons dans un tableau. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" line="228" column="6" bodyfile="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" bodystart="228" bodyend="273"/>
      </memberdef>
      <memberdef kind="function" id="Array__tools_8cpp_1a802ccb4e59263cdfb221f0c64e1eb283" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template void</type>
        <definition>template void tableau_trier_retirer_doublons</definition>
        <argsstring>(IntTab_T&lt; int &gt; &amp;tab)</argsstring>
        <name>tableau_trier_retirer_doublons</name>
        <param>
          <type><ref refid="classTRUSTTab" kindref="compound">IntTab_T</ref>&lt; int &gt; &amp;</type>
          <declname>tab</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" line="281" column="15" declfile="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" declline="281" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="Array__tools_8cpp_1afb6feaa164b51fb25d1649b7883cd0a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename _TYPE_</type>
          </param>
          <param>
            <type>typename _SIZE_</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int tri_lexicographique_tableau</definition>
        <argsstring>(TRUSTTab&lt; _TYPE_, _SIZE_ &gt; &amp;tab)</argsstring>
        <name>tri_lexicographique_tableau</name>
        <param>
          <type><ref refid="classTRUSTTab" kindref="compound">TRUSTTab</ref>&lt; _TYPE_, _SIZE_ &gt; &amp;</type>
          <declname>tab</declname>
        </param>
        <briefdescription>
<para>tri lexicographique du tableau tab (par ordre croissant de la premiere colonne, si premiere colonne identique, ordre croissant </para>
        </briefdescription>
        <detaileddescription>
<para>Tri lexicographique d&apos;un tableau.</para>
<para>de la deuxieme, etc). Le tableau ne doit pas etre un tableau distribue. Valeur de retour: nombre de colonnes du tableau (produit des tab.dimension(i) pour i&gt;0) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" line="137" column="5" bodyfile="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" bodystart="137" bodyend="177"/>
      </memberdef>
      <memberdef kind="function" id="Array__tools_8cpp_1a6cd700b632d22c47542b7470c9607fad" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template int</type>
        <definition>template int tri_lexicographique_tableau</definition>
        <argsstring>(TRUSTTab&lt; double, int &gt; &amp;tab)</argsstring>
        <name>tri_lexicographique_tableau</name>
        <param>
          <type><ref refid="classTRUSTTab" kindref="compound">TRUSTTab</ref>&lt; double, int &gt; &amp;</type>
          <declname>tab</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" line="280" column="14" declfile="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" declline="280" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="Array__tools_8cpp_1a19336f557ea6dc48411173c90456a9be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template int</type>
        <definition>template int tri_lexicographique_tableau</definition>
        <argsstring>(TRUSTTab&lt; int, int &gt; &amp;tab)</argsstring>
        <name>tri_lexicographique_tableau</name>
        <param>
          <type><ref refid="classTRUSTTab" kindref="compound">TRUSTTab</ref>&lt; int, int &gt; &amp;</type>
          <declname>tab</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" line="279" column="14" declfile="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" declline="279" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="Array__tools_8cpp_1a085a08f05dcc0a642ab66787ac4bb7ba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename _TYPE_</type>
          </param>
          <param>
            <type>typename _SIZE_</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int tri_lexicographique_tableau_indirect</definition>
        <argsstring>(const TRUSTTab&lt; _TYPE_, _SIZE_ &gt; &amp;tab, ArrOfInt_T&lt; _SIZE_ &gt; &amp;index)</argsstring>
        <name>tri_lexicographique_tableau_indirect</name>
        <param>
          <type>const <ref refid="classTRUSTTab" kindref="compound">TRUSTTab</ref>&lt; _TYPE_, _SIZE_ &gt; &amp;</type>
          <declname>tab</declname>
        </param>
        <param>
          <type><ref refid="classTRUSTArray" kindref="compound">ArrOfInt_T</ref>&lt; _SIZE_ &gt; &amp;</type>
          <declname>index</declname>
        </param>
        <briefdescription>
<para>Idem que tri_lexicographique_tableau mais on trie le tableau index qui contient les indices de lignes du tableau tab tel que tab(index[i], *) soit. </para>
        </briefdescription>
        <detaileddescription>
<para>Tri indirect (on trie le tableau index qui contient des numeros de lignes dans tab)</para>
<para>croissant quant i augmente. Tri de tous les indices de index... Si le tableau index est de taille nulle, on en cree un de taille tab.dimension_tot(0) Sinon on suppose qu&apos;il contient deja des indices de lignes dans tab. Valeur de retour: nombre de colonnes du tableau (produit des tab.dimension(i) pour i&gt;0) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" line="188" column="5" bodyfile="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" bodystart="188" bodyend="222"/>
      </memberdef>
      <memberdef kind="function" id="Array__tools_8cpp_1af4e4bc60a7f7c76841c5640a521ea3ee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template int</type>
        <definition>template int tri_lexicographique_tableau_indirect</definition>
        <argsstring>(const TRUSTTab&lt; double, int &gt; &amp;tab, ArrOfInt_T&lt; int &gt; &amp;index)</argsstring>
        <name>tri_lexicographique_tableau_indirect</name>
        <param>
          <type>const <ref refid="classTRUSTTab" kindref="compound">TRUSTTab</ref>&lt; double, int &gt; &amp;</type>
          <declname>tab</declname>
        </param>
        <param>
          <type><ref refid="classTRUSTArray" kindref="compound">ArrOfInt_T</ref>&lt; int &gt; &amp;</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" line="278" column="14" declfile="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" declline="278" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="Array__tools_8cpp_1a5338fa3ebf6d05c0aad9a540c77a5f77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template int</type>
        <definition>template int tri_lexicographique_tableau_indirect</definition>
        <argsstring>(const TRUSTTab&lt; int, int &gt; &amp;tab, ArrOfInt_T&lt; int &gt; &amp;index)</argsstring>
        <name>tri_lexicographique_tableau_indirect</name>
        <param>
          <type>const <ref refid="classTRUSTTab" kindref="compound">TRUSTTab</ref>&lt; int, int &gt; &amp;</type>
          <declname>tab</declname>
        </param>
        <param>
          <type><ref refid="classTRUSTArray" kindref="compound">ArrOfInt_T</ref>&lt; int &gt; &amp;</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" line="277" column="14" declfile="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp" declline="277" declcolumn="14"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/****************************************************************************</highlight></codeline>
<codeline lineno="2"><highlight class="comment">*<sp/>Copyright<sp/>(c)<sp/>2025,<sp/>CEA</highlight></codeline>
<codeline lineno="3"><highlight class="comment">*<sp/>All<sp/>rights<sp/>reserved.</highlight></codeline>
<codeline lineno="4"><highlight class="comment">*</highlight></codeline>
<codeline lineno="5"><highlight class="comment">*<sp/>Redistribution<sp/>and<sp/>use<sp/>in<sp/>source<sp/>and<sp/>binary<sp/>forms,<sp/>with<sp/>or<sp/>without<sp/>modification,<sp/>are<sp/>permitted<sp/>provided<sp/>that<sp/>the<sp/>following<sp/>conditions<sp/>are<sp/>met:</highlight></codeline>
<codeline lineno="6"><highlight class="comment">*<sp/>1.<sp/>Redistributions<sp/>of<sp/>source<sp/>code<sp/>must<sp/>retain<sp/>the<sp/>above<sp/>copyright<sp/>notice,<sp/>this<sp/>list<sp/>of<sp/>conditions<sp/>and<sp/>the<sp/>following<sp/>disclaimer.</highlight></codeline>
<codeline lineno="7"><highlight class="comment">*<sp/>2.<sp/>Redistributions<sp/>in<sp/>binary<sp/>form<sp/>must<sp/>reproduce<sp/>the<sp/>above<sp/>copyright<sp/>notice,<sp/>this<sp/>list<sp/>of<sp/>conditions<sp/>and<sp/>the<sp/>following<sp/>disclaimer<sp/>in<sp/>the<sp/>documentation<sp/>and/or<sp/>other<sp/>materials<sp/>provided<sp/>with<sp/>the<sp/>distribution.</highlight></codeline>
<codeline lineno="8"><highlight class="comment">*<sp/>3.<sp/>Neither<sp/>the<sp/>name<sp/>of<sp/>the<sp/>copyright<sp/>holder<sp/>nor<sp/>the<sp/>names<sp/>of<sp/>its<sp/>contributors<sp/>may<sp/>be<sp/>used<sp/>to<sp/>endorse<sp/>or<sp/>promote<sp/>products<sp/>derived<sp/>from<sp/>this<sp/>software<sp/>without<sp/>specific<sp/>prior<sp/>written<sp/>permission.</highlight></codeline>
<codeline lineno="9"><highlight class="comment">*</highlight></codeline>
<codeline lineno="10"><highlight class="comment">*<sp/>THIS<sp/>SOFTWARE<sp/>IS<sp/>PROVIDED<sp/>BY<sp/>THE<sp/>COPYRIGHT<sp/>HOLDERS<sp/>AND<sp/>CONTRIBUTORS<sp/>&quot;AS<sp/>IS&quot;<sp/>AND<sp/>ANY<sp/>EXPRESS<sp/>OR<sp/>IMPLIED<sp/>WARRANTIES,<sp/>INCLUDING,<sp/>BUT<sp/>NOT<sp/>LIMITED<sp/>TO,<sp/>THE<sp/>IMPLIED<sp/>WARRANTIES<sp/>OF<sp/>MERCHANTABILITY<sp/>AND<sp/>FITNESS<sp/>FOR<sp/>A<sp/>PARTICULAR<sp/>PURPOSE<sp/>ARE<sp/>DISCLAIMED.</highlight></codeline>
<codeline lineno="11"><highlight class="comment">*<sp/>IN<sp/>NO<sp/>EVENT<sp/>SHALL<sp/>THE<sp/>COPYRIGHT<sp/>HOLDER<sp/>OR<sp/>CONTRIBUTORS<sp/>BE<sp/>LIABLE<sp/>FOR<sp/>ANY<sp/>DIRECT,<sp/>INDIRECT,<sp/>INCIDENTAL,<sp/>SPECIAL,<sp/>EXEMPLARY,<sp/>OR<sp/>CONSEQUENTIAL<sp/>DAMAGES<sp/>(INCLUDING,<sp/>BUT<sp/>NOT<sp/>LIMITED<sp/>TO,<sp/>PROCUREMENT<sp/>OF<sp/>SUBSTITUTE<sp/>GOODS<sp/>OR<sp/>SERVICES;<sp/>LOSS<sp/>OF<sp/>USE,<sp/>DATA,<sp/>OR<sp/>PROFITS;</highlight></codeline>
<codeline lineno="12"><highlight class="comment">*<sp/>OR<sp/>BUSINESS<sp/>INTERRUPTION)<sp/>HOWEVER<sp/>CAUSED<sp/>AND<sp/>ON<sp/>ANY<sp/>THEORY<sp/>OF<sp/>LIABILITY,<sp/>WHETHER<sp/>IN<sp/>CONTRACT,<sp/>STRICT<sp/>LIABILITY,<sp/>OR<sp/>TORT<sp/>(INCLUDING<sp/>NEGLIGENCE<sp/>OR<sp/>OTHERWISE)<sp/>ARISING<sp/>IN<sp/>ANY<sp/>WAY<sp/>OUT<sp/>OF<sp/>THE<sp/>USE<sp/>OF<sp/>THIS<sp/>SOFTWARE,<sp/>EVEN<sp/>IF<sp/>ADVISED<sp/>OF<sp/>THE<sp/>POSSIBILITY<sp/>OF<sp/>SUCH<sp/>DAMAGE.</highlight></codeline>
<codeline lineno="13"><highlight class="comment">*</highlight></codeline>
<codeline lineno="14"><highlight class="comment">*****************************************************************************/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;Array_tools.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="18"><highlight class="comment">/*!<sp/>@brief<sp/>Trie<sp/>le<sp/>tableau<sp/>array<sp/>dans<sp/>l&apos;ordre<sp/>croissant<sp/>et<sp/>retire<sp/>les<sp/>doublons.</highlight></codeline>
<codeline lineno="19"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="20"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>_TYPE_,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>_SIZE_&gt;</highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>array_trier_retirer_doublons(<ref refid="classTRUSTArray" kindref="compound">TRUSTArray&lt;_TYPE_,_SIZE_&gt;</ref>&amp;<sp/>array)</highlight></codeline>
<codeline lineno="23"><highlight class="normal">{</highlight></codeline>
<codeline lineno="24"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>IntVect<sp/>n&apos;est<sp/>pas<sp/>traite<sp/>correctement<sp/>car<sp/>on<sp/>ne<sp/>fait<sp/>pas<sp/>un<sp/>resize()<sp/>mais<sp/>un<sp/>resize_array().</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="normal"><sp/><sp/>assert(</highlight><highlight class="keyword">typeid</highlight><highlight class="normal">(array)<sp/>!=<sp/></highlight><highlight class="keyword">typeid</highlight><highlight class="normal">(<ref refid="classTRUSTVect" kindref="compound">TRUSTVect&lt;_TYPE_, _SIZE_&gt;</ref>));</highlight></codeline>
<codeline lineno="26"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>_SIZE_<sp/>size<sp/>=<sp/>array.<ref refid="classTRUSTArray_1a48b5aa02624ffdc0bad44ca38ddd1a1c" kindref="member">size_array</ref>();</highlight></codeline>
<codeline lineno="27"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(size<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="28"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="29"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Tri<sp/>dans<sp/>l&apos;ordre<sp/>croissant</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="30"><highlight class="normal"><sp/><sp/>array.<ref refid="classTRUSTArray_1ad31b52ddbe22d4c499c3400933e03561" kindref="member">ordonne_array</ref>();</highlight></codeline>
<codeline lineno="31"><highlight class="normal"></highlight></codeline>
<codeline lineno="32"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Retire<sp/>les<sp/>doublons</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="33"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>last<sp/>=<sp/>std::unique(array.<ref refid="classTRUSTArray_1a62f5eeb66939850d54464bb1e9c34d3d" kindref="member">addr</ref>(),<sp/>array.<ref refid="classTRUSTArray_1a62f5eeb66939850d54464bb1e9c34d3d" kindref="member">addr</ref>()+size);</highlight></codeline>
<codeline lineno="34"><highlight class="normal"><sp/><sp/>_SIZE_<sp/>new_size<sp/>=<sp/><sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">_SIZE_</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(std::distance(array.<ref refid="classTRUSTArray_1a62f5eeb66939850d54464bb1e9c34d3d" kindref="member">addr</ref>(),<sp/>last));</highlight></codeline>
<codeline lineno="35"><highlight class="normal"><sp/><sp/>array.<ref refid="classTRUSTArray_1ad1bd36a32ef2d67b0a3695b5d97ac0ab" kindref="member">resize_array</ref>(new_size);</highlight></codeline>
<codeline lineno="36"><highlight class="normal">}</highlight></codeline>
<codeline lineno="37"><highlight class="normal"></highlight></codeline>
<codeline lineno="38"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="39"><highlight class="comment">/*!<sp/>@brief<sp/>calcule<sp/>l&apos;intersection<sp/>entre<sp/>les<sp/>deux<sp/>listes<sp/>d&apos;entiers<sp/>liste1<sp/>et<sp/>liste2.</highlight></codeline>
<codeline lineno="40"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="41"><highlight class="comment"><sp/>*<sp/>Le<sp/>resultat<sp/>est<sp/>mis<sp/>dans<sp/>liste1.</highlight></codeline>
<codeline lineno="42"><highlight class="comment"><sp/>*<sp/><sp/><sp/>Les<sp/>deux<sp/>listes<sp/>doivent<sp/>etre<sp/>triees<sp/>et<sp/>sans<sp/>doublons.<sp/>liste1<sp/>est</highlight></codeline>
<codeline lineno="43"><highlight class="comment"><sp/>*<sp/><sp/><sp/>triee<sp/>en<sp/>sortie.</highlight></codeline>
<codeline lineno="44"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="45"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="46"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>_TYPE_,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>_SIZE_&gt;</highlight></codeline>
<codeline lineno="47"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>array_calculer_intersection(<ref refid="classTRUSTArray" kindref="compound">TRUSTArray&lt;_TYPE_,_SIZE_&gt;</ref>&amp;<sp/>liste1,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classTRUSTArray" kindref="compound">TRUSTArray&lt;_TYPE_,_SIZE_&gt;</ref>&amp;<sp/>liste2)</highlight></codeline>
<codeline lineno="48"><highlight class="normal">{</highlight></codeline>
<codeline lineno="49"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>_SIZE_<sp/>sz1<sp/>=<sp/>liste1.<ref refid="classTRUSTArray_1a48b5aa02624ffdc0bad44ca38ddd1a1c" kindref="member">size_array</ref>();</highlight></codeline>
<codeline lineno="50"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>_SIZE_<sp/>sz2<sp/>=<sp/>liste2.<ref refid="classTRUSTArray_1a48b5aa02624ffdc0bad44ca38ddd1a1c" kindref="member">size_array</ref>();</highlight></codeline>
<codeline lineno="51"><highlight class="normal"><sp/><sp/>_SIZE_<sp/>j<sp/>=<sp/>0;<sp/></highlight><highlight class="comment">//<sp/>Pointeur<sp/>en<sp/>lecture<sp/>dans<sp/>liste2</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="52"><highlight class="normal"><sp/><sp/>_SIZE_<sp/>k<sp/>=<sp/>0;<sp/></highlight><highlight class="comment">//<sp/>Pointeur<sp/>en<sp/>ecriture</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="53"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(_SIZE_<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>sz1;<sp/>i++)</highlight></codeline>
<codeline lineno="54"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="55"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>On<sp/>verifie<sp/>que<sp/>les<sp/>listes<sp/>sont<sp/>triees<sp/>dans<sp/>l&apos;ordre<sp/>croissant</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="56"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>assert((i<sp/>&gt;=<sp/>sz1-1)<sp/>||<sp/>(liste1[i]<sp/>&lt;<sp/>liste1[i+1]));</highlight></codeline>
<codeline lineno="57"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>assert((j<sp/>&gt;=<sp/>sz2-1)<sp/>||<sp/>(liste2[j]<sp/>&lt;<sp/>liste2[j+1]));</highlight></codeline>
<codeline lineno="58"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>_TYPE_<sp/>valeur_i<sp/>=<sp/>liste1[i];</highlight></codeline>
<codeline lineno="59"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Avancer<sp/>dans<sp/>liste2<sp/>jusqu&apos;a<sp/>trouver<sp/>ou<sp/>depasser<sp/>liste1[i]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="60"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(j<sp/>&lt;<sp/>sz2<sp/>&amp;&amp;<sp/>liste2[j]<sp/>&lt;<sp/>valeur_i)</highlight></codeline>
<codeline lineno="61"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>j++;</highlight></codeline>
<codeline lineno="62"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>sz2)</highlight></codeline>
<codeline lineno="63"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;<sp/></highlight><highlight class="comment">//<sp/>Bout<sp/>de<sp/>liste,<sp/>on<sp/>a<sp/>fini</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(liste2[j]<sp/>==<sp/>valeur_i)</highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>liste1[k]<sp/>=<sp/>valeur_i;</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>k++;<sp/></highlight><highlight class="comment">//<sp/>On<sp/>garde<sp/>cette<sp/>valeur</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/>liste1.<ref refid="classTRUSTArray_1ad1bd36a32ef2d67b0a3695b5d97ac0ab" kindref="member">resize_array</ref>(k);</highlight></codeline>
<codeline lineno="71"><highlight class="normal">}</highlight></codeline>
<codeline lineno="72"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="73"><highlight class="comment">/*!<sp/>@brief<sp/>Retire<sp/>de<sp/>&quot;sorted_array&quot;<sp/>les<sp/>elements<sp/>qui<sp/>figurent<sp/>dans<sp/>&quot;sorted_elements&quot;.</highlight></codeline>
<codeline lineno="74"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="75"><highlight class="comment"><sp/>*<sp/>Les<sp/>deux<sp/>tableaux<sp/>doivent<sp/>etre<sp/>initialement<sp/>ordonnes<sp/>dans<sp/>l&apos;ordre<sp/>croissant.</highlight></codeline>
<codeline lineno="76"><highlight class="comment"><sp/>*<sp/><sp/><sp/>Exemple:</highlight></codeline>
<codeline lineno="77"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>En<sp/>entree<sp/>sorted_array=[1,4,9,10,12,18],<sp/>sorted_elements=[3,5,9,10,18,25]</highlight></codeline>
<codeline lineno="78"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>En<sp/>sortie<sp/>sorted_array=[1,4,12]</highlight></codeline>
<codeline lineno="79"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="80"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="81"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>array_retirer_elements(<ref refid="classTRUSTArray" kindref="compound">ArrOfInt</ref>&amp;<sp/>sorted_array,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classTRUSTArray" kindref="compound">ArrOfInt</ref>&amp;<sp/>sorted_elements_list)</highlight></codeline>
<codeline lineno="82"><highlight class="normal">{</highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i_read;<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Index<sp/>dans<sp/>sorted_array<sp/>(en<sp/>lecture)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="84"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i_write<sp/>=<sp/>0;<sp/></highlight><highlight class="comment">//<sp/>Index<sp/>dans<sp/>sorted_array<sp/>(la<sp/>ou<sp/>on<sp/>ecrit)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Index<sp/>dans<sp/>sorted_elements</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>sorted_array.<ref refid="classTRUSTArray_1a48b5aa02624ffdc0bad44ca38ddd1a1c" kindref="member">size_array</ref>();</highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>m<sp/>=<sp/>sorted_elements_list.<ref refid="classTRUSTArray_1a48b5aa02624ffdc0bad44ca38ddd1a1c" kindref="member">size_array</ref>();</highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="90"><highlight class="normal"></highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j_value<sp/>=<sp/>sorted_elements_list[j];</highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i_read<sp/>=<sp/>0;<sp/>i_read<sp/>&lt;<sp/>n;<sp/>i_read++)</highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Tableau<sp/>trie<sp/>?</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="95"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>assert(i_read<sp/>==<sp/>0<sp/>||<sp/>sorted_array[i_read]<sp/>&gt;<sp/>sorted_array[i_read-1]);</highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i_value<sp/>=<sp/>sorted_array[i_read];</highlight></codeline>
<codeline lineno="97"><highlight class="normal"></highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>On<sp/>avance<sp/>dans<sp/>la<sp/>liste<sp/>sorted_elements<sp/>jusqu&apos;a<sp/>trouver<sp/>ou<sp/>depasser</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>l&apos;element<sp/>i_value</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((j_value<sp/>&lt;<sp/>i_value)<sp/>&amp;&amp;<sp/>(j<sp/>&lt;<sp/>m))</highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>j++;</highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>m)</highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assert(sorted_elements_list[j]<sp/>&gt;<sp/>j_value);<sp/></highlight><highlight class="comment">//<sp/>Tableau<sp/>trie<sp/>?</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>j_value<sp/>=<sp/>sorted_elements_list[j];</highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="108"><highlight class="normal"></highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>==<sp/>m<sp/>||<sp/>j_value<sp/>!=<sp/>i_value)</highlight></codeline>
<codeline lineno="110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>i_value<sp/>ne<sp/>figure<sp/>pas<sp/>dans<sp/>le<sp/>tableau<sp/>sorted_elements,<sp/>on<sp/>le<sp/>garde</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sorted_array[i_write]<sp/>=<sp/>i_value;</highlight></codeline>
<codeline lineno="113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i_write++;</highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/>sorted_array.<ref refid="classTRUSTArray_1ad1bd36a32ef2d67b0a3695b5d97ac0ab" kindref="member">resize_array</ref>(i_write);</highlight></codeline>
<codeline lineno="117"><highlight class="normal">}</highlight></codeline>
<codeline lineno="118"><highlight class="normal"></highlight></codeline>
<codeline lineno="119"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>_SIZE_&gt;</highlight></codeline>
<codeline lineno="120"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>same_line(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classTRUSTTab" kindref="compound">IntTab_T&lt;_SIZE_&gt;</ref>&amp;<sp/>v,<sp/>_SIZE_<sp/>i,<sp/>_SIZE_<sp/>j)</highlight></codeline>
<codeline lineno="121"><highlight class="normal">{</highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ls<sp/>=<sp/>v.<ref refid="classTRUSTVect_1a233c6efc2617385174d5b4b0b29f9a96" kindref="member">line_size</ref>();</highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>ls;<sp/>k++)</highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(v(i,k)<sp/>!=<sp/>v(j,k))</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="127"><highlight class="normal">}</highlight></codeline>
<codeline lineno="128"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="129"><highlight class="comment">/*!<sp/>@brief<sp/>tri<sp/>lexicographique<sp/>du<sp/>tableau<sp/>tab<sp/>(par<sp/>ordre<sp/>croissant<sp/>de<sp/>la<sp/>premiere<sp/>colonne,<sp/>si<sp/>premiere<sp/>colonne<sp/>identique,<sp/>ordre<sp/>croissant</highlight></codeline>
<codeline lineno="130"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="131"><highlight class="comment"><sp/>*<sp/><sp/><sp/>de<sp/>la<sp/>deuxieme,<sp/>etc).</highlight></codeline>
<codeline lineno="132"><highlight class="comment"><sp/>*<sp/><sp/><sp/>Le<sp/>tableau<sp/>ne<sp/>doit<sp/>pas<sp/>etre<sp/>un<sp/>tableau<sp/>distribue.</highlight></codeline>
<codeline lineno="133"><highlight class="comment"><sp/>*<sp/><sp/><sp/>Valeur<sp/>de<sp/>retour:<sp/>nombre<sp/>de<sp/>colonnes<sp/>du<sp/>tableau<sp/>(produit<sp/>des<sp/>tab.dimension(i)<sp/>pour<sp/>i&gt;0)</highlight></codeline>
<codeline lineno="134"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="135"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="136"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>_TYPE_,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>_SIZE_&gt;</highlight></codeline>
<codeline lineno="137"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tri_lexicographique_tableau(<ref refid="classTRUSTTab" kindref="compound">TRUSTTab&lt;_TYPE_,_SIZE_&gt;</ref>&amp;<sp/>tab)</highlight></codeline>
<codeline lineno="138"><highlight class="normal">{</highlight></codeline>
<codeline lineno="139"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>On<sp/>verifie<sp/>que<sp/>le<sp/>tableau<sp/>n&apos;est<sp/>pas<sp/>un<sp/>tableau<sp/>distribue:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="140"><highlight class="normal"><sp/><sp/>assert(!tab.<ref refid="classTRUSTVect_1a96a3b255de1ffa32e594df41b0462458" kindref="member">get_md_vector</ref>().<ref refid="classMD__Vector_1a036f2429ea40bd07b331500f6ff22b8f" kindref="member">non_nul</ref>());</highlight></codeline>
<codeline lineno="141"><highlight class="normal"></highlight></codeline>
<codeline lineno="142"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>_SIZE_<sp/>nb_lignes<sp/>=<sp/>tab.<ref refid="classTRUSTTab_1aee55d6851cd43d179ec3c46262fa0aad" kindref="member">dimension</ref>(0);</highlight></codeline>
<codeline lineno="143"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nb_colonnes<sp/>=<sp/>tab.<ref refid="classTRUSTVect_1a233c6efc2617385174d5b4b0b29f9a96" kindref="member">line_size</ref>();</highlight></codeline>
<codeline lineno="144"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nb_lignes<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>tab.<ref refid="classTRUSTArray_1ac59ae35469553e0d2b793b80968d9415" kindref="member">ensureDataOnHost</ref>();</highlight></codeline>
<codeline lineno="147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nb_colonnes<sp/>==<sp/>1)</highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tab.<ref refid="classTRUSTArray_1ad31b52ddbe22d4c499c3400933e03561" kindref="member">ordonne_array</ref>();</highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nb_colonnes<sp/>==<sp/>2)</highlight></codeline>
<codeline lineno="150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>pairs<sp/>=<sp/>std::array&lt;_TYPE_,<sp/>2&gt;;</highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_TYPE_<sp/>*ptr<sp/>=<sp/>tab.<ref refid="classTRUSTArray_1a62f5eeb66939850d54464bb1e9c34d3d" kindref="member">addr</ref>();</highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pairs*<sp/>tmp<sp/>=<sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal">pairs*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(ptr);</highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::sort(tmp,<sp/>tmp+nb_lignes);</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nb_colonnes<sp/>==<sp/>3)</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>triplets<sp/>=<sp/>std::array&lt;_TYPE_,<sp/>3&gt;;</highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_TYPE_<sp/>*ptr<sp/>=<sp/>tab.<ref refid="classTRUSTArray_1a62f5eeb66939850d54464bb1e9c34d3d" kindref="member">addr</ref>();</highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triplets*<sp/>tmp<sp/>=<sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal">triplets*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(ptr);</highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::sort(tmp,<sp/>tmp+nb_lignes);</highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nb_colonnes<sp/>==<sp/>4)</highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>quadruplets<sp/>=<sp/>std::array&lt;_TYPE_,<sp/>4&gt;;</highlight></codeline>
<codeline lineno="166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_TYPE_<sp/>*ptr<sp/>=<sp/>tab.<ref refid="classTRUSTArray_1a62f5eeb66939850d54464bb1e9c34d3d" kindref="member">addr</ref>();</highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>quadruplets*<sp/>tmp<sp/>=<sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal">quadruplets*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(ptr);</highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::sort(tmp,<sp/>tmp+nb_lignes);</highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;tri_lexicographique_tableau<sp/>not<sp/>supported<sp/>for<sp/>TRUST<sp/>tabs<sp/>with<sp/>more<sp/>than<sp/>4<sp/>columns&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>finl;</highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classProcess_1acc2fbbe761e08e5870ae605c0705491c" kindref="member">Process::exit</ref>();</highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>nb_colonnes;</highlight></codeline>
<codeline lineno="177"><highlight class="normal">}</highlight></codeline>
<codeline lineno="178"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="179"><highlight class="comment">/*!<sp/>@brief<sp/>Idem<sp/>que<sp/>tri_lexicographique_tableau<sp/>mais<sp/>on<sp/>trie<sp/>le<sp/>tableau<sp/>index<sp/>qui<sp/>contient<sp/>les<sp/>indices<sp/>de<sp/>lignes<sp/>du<sp/>tableau<sp/>tab<sp/>tel<sp/>que<sp/>tab(index[i],<sp/>*)<sp/>soit</highlight></codeline>
<codeline lineno="180"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="181"><highlight class="comment"><sp/>*<sp/><sp/><sp/>croissant<sp/>quant<sp/>i<sp/>augmente.<sp/>Tri<sp/>de<sp/>tous<sp/>les<sp/>indices<sp/>de<sp/>index...</highlight></codeline>
<codeline lineno="182"><highlight class="comment"><sp/>*<sp/><sp/><sp/>Si<sp/>le<sp/>tableau<sp/>index<sp/>est<sp/>de<sp/>taille<sp/>nulle,<sp/>on<sp/>en<sp/>cree<sp/>un<sp/>de<sp/>taille<sp/>tab.dimension_tot(0)</highlight></codeline>
<codeline lineno="183"><highlight class="comment"><sp/>*<sp/><sp/><sp/>Sinon<sp/>on<sp/>suppose<sp/>qu&apos;il<sp/>contient<sp/>deja<sp/>des<sp/>indices<sp/>de<sp/>lignes<sp/>dans<sp/>tab.</highlight></codeline>
<codeline lineno="184"><highlight class="comment"><sp/>*<sp/><sp/><sp/>Valeur<sp/>de<sp/>retour:<sp/>nombre<sp/>de<sp/>colonnes<sp/>du<sp/>tableau<sp/>(produit<sp/>des<sp/>tab.dimension(i)<sp/>pour<sp/>i&gt;0)</highlight></codeline>
<codeline lineno="185"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="186"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="187"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>_TYPE_,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>_SIZE_&gt;</highlight></codeline>
<codeline lineno="188"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tri_lexicographique_tableau_indirect(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classTRUSTTab" kindref="compound">TRUSTTab&lt;_TYPE_,_SIZE_&gt;</ref>&amp;<sp/>tab,<sp/><ref refid="classTRUSTArray" kindref="compound">ArrOfInt_T&lt;_SIZE_&gt;</ref>&amp;<sp/>index)</highlight></codeline>
<codeline lineno="189"><highlight class="normal">{</highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>int_t<sp/>=<sp/>_SIZE_;</highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>On<sp/>verifie<sp/>que<sp/>le<sp/>tableau<sp/>n&apos;est<sp/>pas<sp/>un<sp/>tableau<sp/>distribue:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/>assert(!tab.<ref refid="classTRUSTVect_1a96a3b255de1ffa32e594df41b0462458" kindref="member">get_md_vector</ref>().<ref refid="classMD__Vector_1a036f2429ea40bd07b331500f6ff22b8f" kindref="member">non_nul</ref>());</highlight></codeline>
<codeline lineno="193"><highlight class="normal"></highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>int_t<sp/>dimtab<sp/>=<sp/>tab.<ref refid="classTRUSTTab_1ab6a60d41799bf143fad6ff74c6bb7253" kindref="member">dimension_tot</ref>(0);</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(index.<ref refid="classTRUSTArray_1a48b5aa02624ffdc0bad44ca38ddd1a1c" kindref="member">size_array</ref>()<sp/>==<sp/>0<sp/>&amp;&amp;<sp/>dimtab<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>index.<ref refid="classTRUSTArray_1ad1bd36a32ef2d67b0a3695b5d97ac0ab" kindref="member">resize_array</ref>(dimtab,<sp/>RESIZE_OPTIONS::NOCOPY_NOINIT);</highlight></codeline>
<codeline lineno="198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(int_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>dimtab;<sp/>i++)</highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index[i]<sp/>=<sp/>i;</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="201"><highlight class="normal"></highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>int_t<sp/>nb_lignes<sp/>=<sp/>index.<ref refid="classTRUSTArray_1a48b5aa02624ffdc0bad44ca38ddd1a1c" kindref="member">size_array</ref>();</highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nb_colonnes<sp/>=<sp/>tab.<ref refid="classTRUSTVect_1a233c6efc2617385174d5b4b0b29f9a96" kindref="member">line_size</ref>();</highlight></codeline>
<codeline lineno="204"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nb_dim<sp/>=<sp/>tab.<ref refid="classTRUSTTab_1a829be3686b4cf6f076d1dc92870e18f9" kindref="member">nb_dim</ref>();</highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>epsilon<sp/>=<sp/><ref refid="classObjet__U_1a7447e25c68cc8d3a1c06cf99f0565cff" kindref="member">Objet_U::precision_geom</ref>;</highlight></codeline>
<codeline lineno="206"><highlight class="normal"></highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nb_lignes<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::sort(index.<ref refid="classTRUSTArray_1ad8448b0280ac71013a30d57a884467d9" kindref="member">begin</ref>(),<sp/>index.<ref refid="classTRUSTArray_1a3e727fdd7efb3949dcab9cbbc67ebace" kindref="member">end</ref>(),<sp/>[&amp;](int_t<sp/>a,<sp/>int_t<sp/>b)</highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if(nb_dim<sp/>==<sp/>1)</highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>(<sp/>tab(a)&lt;tab(b)<sp/>);</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>nb_colonnes;<sp/>i++)</highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(<sp/>std::fabs(tab(a,i)-tab(b,i))<sp/>&gt;<sp/>epsilon<sp/>)</highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>(<sp/>tab(a,i)&lt;tab(b,i)<sp/>);</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>nb_colonnes;</highlight></codeline>
<codeline lineno="222"><highlight class="normal">}</highlight></codeline>
<codeline lineno="223"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="224"><highlight class="comment">/*!<sp/>@brief<sp/>Trie<sp/>le<sp/>tableau<sp/>tab<sp/>dans<sp/>l&apos;ordre<sp/>lexicographique<sp/>et<sp/>retire<sp/>les<sp/>doublons<sp/>(attention<sp/>[1,2]<sp/>n&apos;est<sp/>pas<sp/>egal<sp/>a<sp/>[2,1])</highlight></codeline>
<codeline lineno="225"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="226"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="227"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>_SIZE_&gt;</highlight></codeline>
<codeline lineno="228"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>tableau_trier_retirer_doublons(<ref refid="classTRUSTTab" kindref="compound">IntTab_T&lt;_SIZE_&gt;</ref>&amp;<sp/>tab)</highlight></codeline>
<codeline lineno="229"><highlight class="normal">{</highlight></codeline>
<codeline lineno="230"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>_SIZE_<sp/>nb_lignes<sp/>=<sp/>tab.<ref refid="classTRUSTTab_1aee55d6851cd43d179ec3c46262fa0aad" kindref="member">dimension</ref>(0);</highlight></codeline>
<codeline lineno="231"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nb_lignes<sp/>==<sp/>0)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="232"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nb_colonnes<sp/>=<sp/>tab.<ref refid="classTRUSTVect_1a233c6efc2617385174d5b4b0b29f9a96" kindref="member">line_size</ref>();</highlight></codeline>
<codeline lineno="233"><highlight class="normal"></highlight></codeline>
<codeline lineno="234"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nb_colonnes<sp/>==<sp/>1)</highlight></codeline>
<codeline lineno="235"><highlight class="normal"><sp/><sp/><sp/><sp/>array_trier_retirer_doublons(tab);</highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>nb_colonnes<sp/>=<sp/>tri_lexicographique_tableau(tab);</highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nb_colonnes<sp/>==<sp/>2)</highlight></codeline>
<codeline lineno="240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_SIZE_<sp/>j<sp/>=<sp/>1;<sp/></highlight><highlight class="comment">//<sp/>Taille<sp/>du<sp/>tableau<sp/>apres<sp/>suppression</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_SIZE_<sp/>last_x<sp/>=<sp/>tab(0,<sp/>0);</highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_SIZE_<sp/>last_y<sp/>=<sp/>tab(0,<sp/>1);</highlight></codeline>
<codeline lineno="244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(_SIZE_<sp/>i<sp/>=<sp/>1;<sp/>i<sp/>&lt;<sp/>nb_lignes;<sp/>i++)</highlight></codeline>
<codeline lineno="245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>_SIZE_<sp/>x<sp/>=<sp/>tab(i,<sp/>0);</highlight></codeline>
<codeline lineno="247"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>_SIZE_<sp/>y<sp/>=<sp/>tab(i,<sp/>1);</highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(x<sp/>!=<sp/>last_x<sp/>||<sp/>y<sp/>!=<sp/>last_y)</highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tab(j,<sp/>0)<sp/>=<sp/>last_x<sp/>=<sp/>x;</highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tab(j,<sp/>1)<sp/>=<sp/>last_y<sp/>=<sp/>y;</highlight></codeline>
<codeline lineno="252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>j++;</highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tab.<ref refid="classTRUSTTab_1abc2ba4a2d6bf370afe3f37f2d3466620" kindref="member">resize_dim0</ref>(j);</highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_SIZE_<sp/>j<sp/>=<sp/>0;<sp/></highlight><highlight class="comment">//<sp/>Derniere<sp/>ligne<sp/>retenue</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(_SIZE_<sp/>i<sp/>=<sp/>1;<sp/>i<sp/>&lt;<sp/>nb_lignes;<sp/>i++)</highlight></codeline>
<codeline lineno="261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Si<sp/>la<sp/>ligne<sp/>i<sp/>est<sp/>differente<sp/>de<sp/>la<sp/>ligne<sp/>j,<sp/>on<sp/>la<sp/>conserve:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!same_line(tab,<sp/>i,<sp/>j))</highlight></codeline>
<codeline lineno="264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="265"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>j++;</highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>nb_colonnes;<sp/>k++)</highlight></codeline>
<codeline lineno="267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tab(j,<sp/>k)<sp/>=<sp/>tab(i,<sp/>k);</highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tab.<ref refid="classTRUSTTab_1abc2ba4a2d6bf370afe3f37f2d3466620" kindref="member">resize_dim0</ref>(j+1);</highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="272"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="273"><highlight class="normal">}</highlight></codeline>
<codeline lineno="274"><highlight class="normal"></highlight></codeline>
<codeline lineno="275"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Explicit<sp/>instanciations</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="276"><highlight class="normal"></highlight><highlight class="comment">//template<sp/>const<sp/>IntVect_T&lt;int&gt;<sp/>*fct_qsort_tab_ptr&lt;int&gt;;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="277"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tri_lexicographique_tableau_indirect(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classTRUSTTab" kindref="compound">TRUSTTab&lt;int,int&gt;</ref>&amp;<sp/>tab,<sp/><ref refid="classTRUSTArray" kindref="compound">ArrOfInt_T&lt;int&gt;</ref>&amp;<sp/>index);</highlight></codeline>
<codeline lineno="278"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tri_lexicographique_tableau_indirect(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classTRUSTTab" kindref="compound">TRUSTTab&lt;double,int&gt;</ref>&amp;<sp/>tab,<sp/><ref refid="classTRUSTArray" kindref="compound">ArrOfInt_T&lt;int&gt;</ref>&amp;<sp/>index);</highlight></codeline>
<codeline lineno="279"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tri_lexicographique_tableau(<ref refid="classTRUSTTab" kindref="compound">TRUSTTab&lt;int,int&gt;</ref>&amp;<sp/>tab);</highlight></codeline>
<codeline lineno="280"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tri_lexicographique_tableau(<ref refid="classTRUSTTab" kindref="compound">TRUSTTab&lt;double,int&gt;</ref>&amp;<sp/>tab);</highlight></codeline>
<codeline lineno="281"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>tableau_trier_retirer_doublons(<ref refid="classTRUSTTab" kindref="compound">IntTab_T&lt;int&gt;</ref>&amp;<sp/>tab);</highlight></codeline>
<codeline lineno="282"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>array_calculer_intersection(<ref refid="classTRUSTArray" kindref="compound">TRUSTArray&lt;int,int&gt;</ref>&amp;<sp/>liste1,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classTRUSTArray" kindref="compound">TRUSTArray&lt;int,int&gt;</ref>&amp;<sp/>liste2);</highlight></codeline>
<codeline lineno="283"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>array_trier_retirer_doublons(<ref refid="classTRUSTArray" kindref="compound">TRUSTArray&lt;int,int&gt;</ref>&amp;<sp/>array);</highlight></codeline>
<codeline lineno="284"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>array_trier_retirer_doublons(<ref refid="classTRUSTArray" kindref="compound">TRUSTArray&lt;double,int&gt;</ref>&amp;<sp/>array);</highlight></codeline>
<codeline lineno="285"><highlight class="normal"></highlight></codeline>
<codeline lineno="286"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>INT_is_64_<sp/>==<sp/>2</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="287"><highlight class="normal"></highlight><highlight class="comment">//template<sp/>const<sp/>IntVect_T&lt;trustIdType&gt;<sp/>*fct_qsort_tab_ptr&lt;trustIdType&gt;;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="288"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tri_lexicographique_tableau_indirect(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classTRUSTTab" kindref="compound">TRUSTTab&lt;int,trustIdType&gt;</ref>&amp;<sp/>tab,<sp/><ref refid="classTRUSTArray" kindref="compound">ArrOfInt_T&lt;trustIdType&gt;</ref>&amp;<sp/>index);</highlight></codeline>
<codeline lineno="289"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tri_lexicographique_tableau_indirect(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classTRUSTTab" kindref="compound">TRUSTTab&lt;trustIdType,trustIdType&gt;</ref>&amp;<sp/>tab,<sp/><ref refid="classTRUSTArray" kindref="compound">ArrOfInt_T&lt;trustIdType&gt;</ref>&amp;<sp/>index);</highlight></codeline>
<codeline lineno="290"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tri_lexicographique_tableau_indirect(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classTRUSTTab" kindref="compound">TRUSTTab&lt;double,trustIdType&gt;</ref>&amp;<sp/>tab,<sp/><ref refid="classTRUSTArray" kindref="compound">ArrOfInt_T&lt;trustIdType&gt;</ref>&amp;<sp/>index);</highlight></codeline>
<codeline lineno="291"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tri_lexicographique_tableau(<ref refid="classTRUSTTab" kindref="compound">TRUSTTab&lt;int,trustIdType&gt;</ref>&amp;<sp/>tab);</highlight></codeline>
<codeline lineno="292"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tri_lexicographique_tableau(<ref refid="classTRUSTTab" kindref="compound">TRUSTTab&lt;trustIdType,int&gt;</ref>&amp;<sp/>tab);</highlight></codeline>
<codeline lineno="293"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tri_lexicographique_tableau(<ref refid="classTRUSTTab" kindref="compound">TRUSTTab&lt;trustIdType,trustIdType&gt;</ref>&amp;<sp/>tab);</highlight></codeline>
<codeline lineno="294"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tri_lexicographique_tableau(<ref refid="classTRUSTTab" kindref="compound">TRUSTTab&lt;double,trustIdType&gt;</ref>&amp;<sp/>tab);</highlight></codeline>
<codeline lineno="295"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>tableau_trier_retirer_doublons(<ref refid="classTRUSTTab" kindref="compound">IntTab_T&lt;trustIdType&gt;</ref>&amp;<sp/>tab);</highlight></codeline>
<codeline lineno="296"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>array_calculer_intersection(<ref refid="classTRUSTArray" kindref="compound">TRUSTArray&lt;int,trustIdType&gt;</ref>&amp;<sp/>liste1,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classTRUSTArray" kindref="compound">TRUSTArray&lt;int,trustIdType&gt;</ref>&amp;<sp/>liste2);</highlight></codeline>
<codeline lineno="297"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>array_trier_retirer_doublons(<ref refid="classTRUSTArray" kindref="compound">TRUSTArray&lt;int,trustIdType&gt;</ref>&amp;<sp/>array);</highlight></codeline>
<codeline lineno="298"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>array_trier_retirer_doublons(<ref refid="classTRUSTArray" kindref="compound">TRUSTArray&lt;trustIdType,trustIdType&gt;</ref>&amp;<sp/>array);</highlight></codeline>
<codeline lineno="299"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>array_trier_retirer_doublons(<ref refid="classTRUSTArray" kindref="compound">TRUSTArray&lt;double,trustIdType&gt;</ref>&amp;<sp/>array);</highlight></codeline>
<codeline lineno="300"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="301"><highlight class="normal"></highlight></codeline>
<codeline lineno="302"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="303"><highlight class="comment">/*!<sp/>@brief<sp/>cherche<sp/>par<sp/>un<sp/>tri<sp/>lexicographique<sp/>les<sp/>lignes<sp/>identiques<sp/>de<sp/>&quot;tab&quot;<sp/>et<sp/>initialise<sp/>les<sp/>tailles<sp/>et<sp/>contenus<sp/>de<sp/>renum<sp/>et<sp/>renum_inverse.</highlight></codeline>
<codeline lineno="304"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="305"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>renum<sp/>est<sp/>de<sp/>taille<sp/>tab.dimension_tot(0).</highlight></codeline>
<codeline lineno="306"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>renum[i]<sp/>contiendra<sp/>l&apos;indice<sp/>de<sp/>la<sp/>ligne<sp/>i<sp/>dans<sp/>le<sp/>tableau<sp/>reduit<sp/>trie<sp/>(contenant<sp/>les<sp/>lignes<sp/>uniques)</highlight></codeline>
<codeline lineno="307"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>renum_inverse<sp/>contient,<sp/>pour<sp/>chaque<sp/>ligne<sp/>du<sp/>tableau<sp/>reduit<sp/>trie,<sp/>le<sp/>plus<sp/>petit<sp/>indice<sp/>de<sp/>la<sp/>ligne</highlight></codeline>
<codeline lineno="308"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>correspondante<sp/>dans<sp/>tab.</highlight></codeline>
<codeline lineno="309"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>on<sp/>peut<sp/>construire<sp/>le<sp/>tableau<sp/>reduit<sp/>trie<sp/>en<sp/>extayant<sp/>les<sp/>lignes<sp/>tab(<sp/>renum_inverse[i],<sp/>...)</highlight></codeline>
<codeline lineno="310"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="311"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="312"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>calculer_renum_sans_doublons(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classTRUSTTab" kindref="compound">IntTab</ref>&amp;<sp/>tab,<sp/><ref refid="classTRUSTArray" kindref="compound">ArrOfInt</ref>&amp;<sp/>renum,<sp/><ref refid="classTRUSTArray" kindref="compound">ArrOfInt</ref>&amp;<sp/>renum_inverse)</highlight></codeline>
<codeline lineno="313"><highlight class="normal">{</highlight></codeline>
<codeline lineno="314"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>MODIF<sp/>ELI<sp/>LAUCOIN<sp/>31/01/2012<sp/>:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="315"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Je<sp/>re-ecris<sp/>completement<sp/>cette<sp/>fonction</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="316"><highlight class="normal"></highlight></codeline>
<codeline lineno="317"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>index<sp/>permet<sp/>de<sp/>parcourir<sp/>le<sp/>tableau<sp/>tab<sp/>dans<sp/>l&apos;ordre</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="318"><highlight class="normal"><sp/><sp/><ref refid="classTRUSTArray" kindref="compound">ArrOfInt</ref><sp/>index;</highlight></codeline>
<codeline lineno="319"><highlight class="normal"><sp/><sp/>tri_lexicographique_tableau_indirect(tab,<sp/>index);</highlight></codeline>
<codeline lineno="320"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>index.<ref refid="classTRUSTArray_1a48b5aa02624ffdc0bad44ca38ddd1a1c" kindref="member">size_array</ref>();</highlight></codeline>
<codeline lineno="321"><highlight class="normal"></highlight></codeline>
<codeline lineno="322"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>on<sp/>redimensionne<sp/>renum<sp/>et<sp/>renum_index</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="323"><highlight class="normal"><sp/><sp/>renum.<ref refid="classTRUSTArray_1ad1bd36a32ef2d67b0a3695b5d97ac0ab" kindref="member">resize_array</ref>(n,<sp/>RESIZE_OPTIONS::NOCOPY_NOINIT);</highlight></codeline>
<codeline lineno="324"><highlight class="normal"><sp/><sp/>renum_inverse.<ref refid="classTRUSTArray_1ad1bd36a32ef2d67b0a3695b5d97ac0ab" kindref="member">resize_array</ref>(n,<sp/>RESIZE_OPTIONS::NOCOPY_NOINIT);</highlight></codeline>
<codeline lineno="325"><highlight class="normal"></highlight></codeline>
<codeline lineno="326"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/><sp/>=<sp/>-1;<sp/></highlight><highlight class="comment">//<sp/>compteur<sp/>de<sp/>lignes<sp/>dans<sp/>le<sp/>tableau<sp/>reduit</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>latest<sp/>=<sp/>-1;<sp/></highlight><highlight class="comment">//<sp/>indice<sp/>dans<sp/>le<sp/>tableau<sp/>initial<sp/>de<sp/>la<sp/>derniere<sp/>ligne<sp/>ajoutee<sp/>dans<sp/>le<sp/>tableau<sp/>reduit</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="328"><highlight class="normal"></highlight></codeline>
<codeline lineno="329"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;n;<sp/>++i)</highlight></codeline>
<codeline lineno="330"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>on<sp/>parcourt<sp/>tab<sp/>dans<sp/>l&apos;ordre<sp/>croissant<sp/>donne<sp/>par<sp/>index.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>si<sp/>la<sp/>ligne<sp/>courante<sp/>est<sp/>differente<sp/>de<sp/>la<sp/>derniere<sp/>ligne<sp/>ajoutee<sp/>dans<sp/>le<sp/>tableau<sp/>reduit,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>on<sp/>incremente<sp/>count<sp/>et<sp/>on<sp/>met<sp/>a<sp/>jour<sp/>latest.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>(<sp/>latest<sp/>&lt;<sp/>0<sp/>)<sp/>||<sp/>(<sp/>!(same_line(tab,index[i],index[latest])))<sp/>)</highlight></codeline>
<codeline lineno="335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++count;</highlight></codeline>
<codeline lineno="337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>latest=i;</highlight></codeline>
<codeline lineno="338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="339"><highlight class="normal"></highlight></codeline>
<codeline lineno="340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>on<sp/>indique<sp/>dans<sp/>renum<sp/>ou<sp/>se<sp/>trouve<sp/>la<sp/>ligne<sp/>courante<sp/>dans<sp/>le<sp/>tableau<sp/>reduit</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>renum[index[i]]<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>count;</highlight></codeline>
<codeline lineno="342"><highlight class="normal"></highlight></codeline>
<codeline lineno="343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>on<sp/>ajoute<sp/>la<sp/>derniere<sp/>ligne<sp/>traitee<sp/>au<sp/>tableau<sp/>reduit</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>renum_inverse[count]<sp/>=<sp/>index[latest];</highlight></codeline>
<codeline lineno="345"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="346"><highlight class="normal"></highlight></codeline>
<codeline lineno="347"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>on<sp/>redimensionne<sp/>renum_inverse<sp/>a<sp/>la<sp/>taille<sp/>du<sp/>tableau<sp/>reduit</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="348"><highlight class="normal"></highlight></codeline>
<codeline lineno="349"><highlight class="normal"><sp/><sp/>renum_inverse.<ref refid="classTRUSTArray_1ad1bd36a32ef2d67b0a3695b5d97ac0ab" kindref="member">resize_array</ref>(count+1);</highlight></codeline>
<codeline lineno="350"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>FIN<sp/>MODIF<sp/>ELI<sp/>LAUCOIN<sp/>31/01/2012</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="351"><highlight class="normal">}</highlight></codeline>
<codeline lineno="352"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="353"><highlight class="comment">/*!<sp/>@brief<sp/>cherche<sp/>la<sp/>&quot;valeur&quot;<sp/>dans<sp/>le<sp/>tableau<sp/>tab<sp/>par<sp/>recherche<sp/>binaire<sp/>Le<sp/>tableau<sp/>tab<sp/>doit<sp/>etre<sp/>trie<sp/>dans<sp/>l&apos;ordre<sp/>croissant</highlight></codeline>
<codeline lineno="354"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="355"><highlight class="comment">*<sp/><sp/><sp/>Si<sp/>elle<sp/>n&apos;est<sp/>pas<sp/>trouvee,<sp/>renvoie<sp/>-1<sp/>(y<sp/>compris<sp/>si<sp/>tab<sp/>est<sp/>vide),</highlight></codeline>
<codeline lineno="356"><highlight class="comment"><sp/>*<sp/><sp/><sp/>sinon,<sp/>renvoie<sp/>un<sp/>index<sp/>i<sp/>tel<sp/>que<sp/>tab[i]<sp/>==<sp/>valeur</highlight></codeline>
<codeline lineno="357"><highlight class="comment"><sp/>*<sp/><sp/><sp/>(si<sp/>la<sp/>valeur<sp/>figure<sp/>plusieurs<sp/>fois<sp/>dans<sp/>le<sp/>tableau,<sp/>on<sp/>ne<sp/>renvoie</highlight></codeline>
<codeline lineno="358"><highlight class="comment"><sp/>*<sp/><sp/><sp/>pas<sp/>forcement<sp/>la<sp/>premiere<sp/>occurence).</highlight></codeline>
<codeline lineno="359"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="360"><highlight class="comment"><sp/>*<sp/><sp/>Utilise<sp/>dans<sp/>Trio<sp/>!</highlight></codeline>
<codeline lineno="361"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="362"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>array_bsearch(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classTRUSTArray" kindref="compound">ArrOfInt</ref>&amp;<sp/>tab,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>valeur)</highlight></codeline>
<codeline lineno="363"><highlight class="normal">{</highlight></codeline>
<codeline lineno="364"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>attention<sp/>tout<sp/>est<sp/>important<sp/>!</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="365"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="366"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>tab.<ref refid="classTRUSTArray_1a48b5aa02624ffdc0bad44ca38ddd1a1c" kindref="member">size_array</ref>();<sp/></highlight><highlight class="comment">//<sp/>j<sp/>=<sp/>fin<sp/>de<sp/>tableau<sp/>+<sp/>1<sp/>(important)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="367"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(j<sp/>&gt;<sp/>i)</highlight></codeline>
<codeline lineno="368"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Le<sp/>tableau<sp/>doit<sp/>etre<sp/>trie</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>assert(j<sp/>==<sp/>tab.<ref refid="classTRUSTArray_1a48b5aa02624ffdc0bad44ca38ddd1a1c" kindref="member">size_array</ref>()<sp/>||<sp/>tab[i]<sp/>&lt;=<sp/>tab[j]);</highlight></codeline>
<codeline lineno="371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>milieu<sp/>=<sp/>(i<sp/>+<sp/>j)<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>val<sp/>=<sp/>tab[milieu];</highlight></codeline>
<codeline lineno="373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(val<sp/>&gt;<sp/>valeur)</highlight></codeline>
<codeline lineno="374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>j<sp/>=<sp/>milieu;<sp/></highlight><highlight class="comment">//<sp/>prendre<sp/>la<sp/>valeur<sp/>milieu<sp/>et<sp/>pas<sp/>milieu<sp/>-<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(val<sp/>&lt;<sp/>valeur)</highlight></codeline>
<codeline lineno="376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>milieu<sp/>+<sp/>1;<sp/></highlight><highlight class="comment">//<sp/>prendre<sp/>la<sp/>valeur<sp/>milieu<sp/>+<sp/>1<sp/>et<sp/>pas<sp/>milieu</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>milieu;</highlight></codeline>
<codeline lineno="379"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="380"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Si<sp/>on<sp/>arrive<sp/>ici,<sp/>c&apos;est<sp/>que<sp/>i==j,<sp/>donc</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="381"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>-<sp/>soit<sp/>j<sp/>==<sp/>fin<sp/>de<sp/>tableau<sp/>+<sp/>1<sp/>et<sp/>on<sp/>n&apos;a<sp/>pas<sp/>trouve<sp/>la<sp/>valeur</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="382"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>-<sp/>soit<sp/>tab[j]<sp/>a<sp/>ete<sp/>teste<sp/>et<sp/>n&apos;est<sp/>pas<sp/>egale<sp/>a<sp/>valeur</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="383"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Dans<sp/>les<sp/>deux<sp/>cas,<sp/>valeur<sp/>n&apos;est<sp/>pas<sp/>dans<sp/>le<sp/>tableau</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="384"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline lineno="385"><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="/volatile/catA/gj277443/TRUST/sync-doc/src/Kernel/Math/Array_tools.cpp"/>
  </compounddef>
</doxygen>
